import express from "express"
import Subscription from "../models/Subscription.js"
import TrafficPackage from "../models/TrafficPackage.js"
import User from "../models/User.js"
import Server from "../models/Server.js"
import syncService from "../services/syncService.js"

const router = express.Router()

// Get all traffic packages available for purchase
router.get("/packages", async (req, res) => {
  try {
    const packages = await TrafficPackage.find({ isActive: true }).sort({ sortOrder: 1, price: 1 })
    res.json(packages)
  } catch (error) {
    res.status(500).json({ error: error.message })
  }
})

router.post("/packages", async (req, res) => {
  try {
    const { name, description, trafficAmount, price, currency, validityDays } = req.body

    const trafficPackage = new TrafficPackage({
      name,
      description,
      trafficAmount,
      price,
      currency,
      validityDays,
    })

    await trafficPackage.save({ validateBeforeSave: false })
    res.status(201).json(trafficPackage)
  } catch (error) {
    res.status(400).json({ error: error.message })
  }
})

router.post("/purchase", async (req, res) => {
  try {
    const { userId, packageId, nickname } = req.body

    const user = await User.findById(userId)
    const trafficPackage = await TrafficPackage.findById(packageId)

    if (!user) {
      return res.status(404).json({ error: "User not found" })
    }
    if (!trafficPackage) {
      return res.status(404).json({ error: "Package not found" })
    }

    // Calculate expiry date
    const expiresAt = new Date()
    expiresAt.setDate(expiresAt.getDate() + trafficPackage.validityDays)

    // Create subscription with its own UUID (auto-generated by model)
    const subscription = new Subscription({
      user: userId,
      packageName: trafficPackage.name,
      price: trafficPackage.price,
      trafficLimit: trafficPackage.trafficAmount,
      expiresAt,
      nickname: nickname || trafficPackage.name,
    })

    await subscription.save({ validateBeforeSave: false })

    res.status(201).json({
      message: "Package purchased successfully",
      subscription,
    })
  } catch (error) {
    res.status(400).json({ error: error.message })
  }
})

// Get all subscriptions
router.get("/", async (req, res) => {
  try {
    const subscriptions = await Subscription.find().populate("user currentServer")
    res.json(subscriptions)
  } catch (error) {
    res.status(500).json({ error: error.message })
  }
})

// Get subscription by ID
router.get("/:id", async (req, res) => {
  try {
    const subscription = await Subscription.findById(req.params.id).populate("user currentServer")
    if (!subscription) {
      return res.status(404).json({ error: "Subscription not found" })
    }
    res.json(subscription)
  } catch (error) {
    res.status(500).json({ error: error.message })
  }
})

router.get("/user/:userId", async (req, res) => {
  try {
    const subscriptions = await Subscription.find({ user: req.params.userId })
      .sort({ purchaseDate: -1 })
      .populate("currentServer")

    res.json(subscriptions)
  } catch (error) {
    res.status(500).json({ error: error.message })
  }
})

router.get("/user/:userId/active", async (req, res) => {
  try {
    const subscriptions = await Subscription.find({
      user: req.params.userId,
      status: "active",
    })
      .sort({ purchaseDate: -1 })
      .populate("currentServer")

    res.json(subscriptions)
  } catch (error) {
    res.status(500).json({ error: error.message })
  }
})

router.post("/:id/select-server/:serverId", async (req, res) => {
  try {
    const subscription = await Subscription.findById(req.params.id).populate("currentServer user")
    const newServer = await Server.findById(req.params.serverId)

    if (!subscription) {
      return res.status(404).json({ error: "Subscription not found" })
    }
    if (!newServer) {
      return res.status(404).json({ error: "Server not found" })
    }

    // Check if subscription has traffic remaining
    if (!subscription.hasTrafficRemaining()) {
      return res.status(403).json({ error: "No traffic remaining for this subscription" })
    }

    // Check if subscription can change server
    if (subscription.currentServer && !subscription.canChangeServer()) {
      const nextChangeTime = new Date(subscription.lastServerChange)
      nextChangeTime.setDate(nextChangeTime.getDate() + 1)

      return res.status(429).json({
        error: "You can only change server once per day",
        nextChangeAllowed: nextChangeTime,
      })
    }

    // Remove from old server if exists
    if (subscription.currentServer) {
      const oldServer = subscription.currentServer
      const oldXrayClient = new (await import("../services/xrayClient.js")).default(oldServer.host, oldServer.grpcPort)

      const removeResult = await oldXrayClient.removeInboundUser("vless-in", subscription.getXrayEmail())
      console.log("[v0] User removal result:", {
        isDeleted: removeResult.isDeleted,
        email: subscription.getXrayEmail(),
      })

      // If removal failed, log but continue (user might not exist on server)
      if (!removeResult.isDeleted) {
        console.log(`[v0] Warning: User ${subscription.getXrayEmail()} was not found on old server ${oldServer.name}`)
      }

      oldServer.currentUsers = Math.max(0, oldServer.currentUsers - 1)
      await oldServer.save({ validateBeforeSave: false })
    }

    // Add to new server using subscription's UUID
    const XrayClient = (await import("../services/xrayClient.js")).default
    const xrayClient = new XrayClient(newServer.host, newServer.grpcPort)

    await xrayClient.addVlessUser("vless-in", {
      email: subscription.getXrayEmail(),
      uuid: subscription.uuid,
      flow: "",
    })

    newServer.currentUsers += 1
    await newServer.save({ validateBeforeSave: false })

    // Update subscription
    subscription.currentServer = newServer._id
    subscription.lastServerChange = new Date()
    subscription.status = "active"
    await subscription.save({ validateBeforeSave: false })

    // Sync subscription to server config
    await syncService.syncSubscription(subscription._id)

    res.json({
      message: "Server changed successfully",
      subscription,
    })
  } catch (error) {
    res.status(500).json({ error: error.message })
  }
})

router.get("/:id/config", async (req, res) => {
  try {
    const subscription = await Subscription.findById(req.params.id).populate("currentServer user")
    if (!subscription) {
      return res.status(404).json({ error: "Subscription not found" })
    }

    if (!subscription.currentServer) {
      return res.status(400).json({ error: "No server selected. Please select a server first." })
    }

    const server = subscription.currentServer

    const totalTrafficUsed = subscription.trafficUsed.reduce((sum, val) => sum + val, 0)

    // VLESS config using subscription's UUID
    const vlessLink =
      `vless://${subscription.uuid}@${server.host}:${server.vlessPort || 8443}?` +
      `encryption=none&security=none&type=tcp#${encodeURIComponent(subscription.nickname || subscription.packageName)}`

    res.json({
      subscription: {
        id: subscription._id,
        nickname: subscription.nickname,
        uuid: subscription.uuid,
      },
      currentServer: server.name,
      trafficRemaining: Math.max(0, subscription.trafficLimit - totalTrafficUsed),
      trafficUsed: totalTrafficUsed,
      trafficLimit: subscription.trafficLimit,
      expiresAt: subscription.expiresAt,
      config: {
        protocol: "vless",
        server: server.name,
        link: vlessLink,
      },
    })
  } catch (error) {
    res.status(500).json({ error: error.message })
  }
})

router.patch("/:id/nickname", async (req, res) => {
  try {
    const { nickname } = req.body
    const subscription = await Subscription.findById(req.params.id)

    if (!subscription) {
      return res.status(404).json({ error: "Subscription not found" })
    }

    subscription.nickname = nickname
    await subscription.save({ validateBeforeSave: false })

    res.json({ message: "Nickname updated", subscription })
  } catch (error) {
    res.status(500).json({ error: error.message })
  }
})

// Get expiring subscriptions
router.get("/expiring/:days", async (req, res) => {
  try {
    const days = Number.parseInt(req.params.days) || 7
    const expiryDate = new Date()
    expiryDate.setDate(expiryDate.getDate() + days)

    const subscriptions = await Subscription.find({
      status: "active",
      endDate: { $lte: expiryDate, $gte: new Date() },
    }).populate("user")

    res.json({
      count: subscriptions.length,
      subscriptions,
    })
  } catch (error) {
    res.status(500).json({ error: error.message })
  }
})

// Create new subscription
router.post("/", async (req, res) => {
  try {
    const { userId, plan, price, duration, trafficLimit } = req.body

    const user = await User.findById(userId)
    if (!user) {
      return res.status(404).json({ error: "User not found" })
    }

    const endDate = new Date()
    endDate.setDate(endDate.getDate() + duration)

    const subscription = new Subscription({
      user: userId,
      plan,
      price,
      duration,
      trafficLimit,
      endDate,
    })

    await subscription.save({ validateBeforeSave: false })

    res.status(201).json(subscription)
  } catch (error) {
    res.status(400).json({ error: error.message })
  }
})

// Cancel subscription
router.post("/:id/cancel", async (req, res) => {
  try {
    const subscription = await Subscription.findById(req.params.id)
    if (!subscription) {
      return res.status(404).json({ error: "Subscription not found" })
    }

    subscription.status = "cancelled"
    subscription.autoRenew = false
    await subscription.save({ validateBeforeSave: false })

    res.json({ message: "Subscription cancelled", subscription })
  } catch (error) {
    res.status(500).json({ error: error.message })
  }
})

// Renew subscription
router.post("/:id/renew", async (req, res) => {
  try {
    const subscription = await Subscription.findById(req.params.id).populate("user")
    if (!subscription) {
      return res.status(404).json({ error: "Subscription not found" })
    }

    const { duration, trafficLimit } = req.body

    const newEndDate = new Date(subscription.endDate)
    newEndDate.setDate(newEndDate.getDate() + (duration || subscription.duration))

    subscription.endDate = newEndDate
    subscription.status = "active"
    if (trafficLimit) subscription.trafficLimit = trafficLimit

    await subscription.save({ validateBeforeSave: false })

    // Update user
    const user = subscription.user
    user.expiresAt = newEndDate
    if (trafficLimit) user.trafficLimit = trafficLimit
    user.status = "active"
    await user.save({ validateBeforeSave: false })

    res.json({
      message: "Subscription renewed successfully",
      subscription,
    })
  } catch (error) {
    res.status(500).json({ error: error.message })
  }
})

// Toggle auto-renew
router.post("/:id/auto-renew", async (req, res) => {
  try {
    const subscription = await Subscription.findById(req.params.id)
    if (!subscription) {
      return res.status(404).json({ error: "Subscription not found" })
    }

    subscription.autoRenew = !subscription.autoRenew
    await subscription.save({ validateBeforeSave: false })

    res.json({
      message: `Auto-renew ${subscription.autoRenew ? "enabled" : "disabled"}`,
      subscription,
    })
  } catch (error) {
    res.status(500).json({ error: error.message })
  }
})

// Get subscription statistics
router.get("/stats/overview", async (req, res) => {
  try {
    const totalSubscriptions = await Subscription.countDocuments()
    const activeSubscriptions = await Subscription.countDocuments({ status: "active" })
    const depletedSubscriptions = await Subscription.countDocuments({ status: "depleted" })
    const expiredSubscriptions = await Subscription.countDocuments({ status: "expired" })

    const revenue = await Subscription.aggregate([{ $group: { _id: null, total: { $sum: "$price" } } }])

    const packageDistribution = await Subscription.aggregate([
      { $group: { _id: "$packageName", count: { $sum: 1 }, revenue: { $sum: "$price" } } },
    ])

    res.json({
      overview: {
        total: totalSubscriptions,
        active: activeSubscriptions,
        depleted: depletedSubscriptions,
        expired: expiredSubscriptions,
        revenue: revenue[0]?.total || 0,
      },
      packageDistribution,
    })
  } catch (error) {
    res.status(500).json({ error: error.message })
  }
})

router.post("/activate-by-payment", async (req, res) => {
  try {
    const { paymentId, invoiceId, userId, packageId } = req.body

    const user = await User.findById(userId)
    const trafficPackage = await TrafficPackage.findById(packageId)

    if (!user) {
      return res.status(404).json({ error: "User not found" })
    }
    if (!trafficPackage) {
      return res.status(404).json({ error: "Package not found" })
    }

    // Calculate expiry date
    const expiresAt = new Date()
    expiresAt.setDate(expiresAt.getDate() + trafficPackage.validityDays)

    // Create subscription with its own UUID (auto-generated by model)
    const subscription = new Subscription({
      user: userId,
      packageName: trafficPackage.name,
      price: trafficPackage.price,
      trafficLimit: trafficPackage.trafficAmount,
      expiresAt,
      nickname: trafficPackage.name,
      status: "active",
      purchaseDate: new Date(),
    })

    await subscription.save({ validateBeforeSave: false })

    console.log(`[Subscription] Created subscription ${subscription._id} for user ${userId} via payment ${paymentId}`)

    res.status(201).json({
      message: "Subscription activated successfully",
      subscription,
    })
  } catch (error) {
    console.error("[Subscription] Error activating subscription:", error)
    res.status(500).json({ error: error.message })
  }
})

router.post("/activate", async (req, res) => {
  try {
    const { userId, packageId, invoiceId } = req.body

    const user = await User.findById(userId)
    const trafficPackage = await TrafficPackage.findById(packageId)

    if (!user) {
      return res.status(404).json({ error: "User not found" })
    }
    if (!trafficPackage) {
      return res.status(404).json({ error: "Package not found" })
    }

    // Calculate expiry date
    const expiresAt = new Date()
    expiresAt.setDate(expiresAt.getDate() + trafficPackage.validityDays)

    // Create subscription with its own UUID (auto-generated by model)
    const subscription = new Subscription({
      user: userId,
      packageName: trafficPackage.name,
      price: trafficPackage.price,
      trafficLimit: trafficPackage.trafficAmount,
      expiresAt,
      nickname: trafficPackage.name,
      status: "active",
      purchaseDate: new Date(),
    })

    await subscription.save({ validateBeforeSave: false })

    console.log(`[Subscription] Created subscription ${subscription._id} for user ${userId} via invoice ${invoiceId}`)

    res.status(201).json({
      message: "Subscription activated successfully",
      subscription,
    })
  } catch (error) {
    console.error("[Subscription] Error activating subscription:", error)
    res.status(500).json({ error: error.message })
  }
})

export default router
